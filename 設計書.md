## JavaScript 3Dゲーム設計書 (Three.js使用) - 更新版

この設計書は、JavaScriptとThree.jsを用いて、3レーンを移動しながら障害物を避ける3Dゲームを開発するためのものです。フェーズ分けを行い、各フェーズのタスクを細かく記述します。

**フェーズ分け (非常に細かい粒度):**

**フェーズ1: プロジェクト初期設定と基本構造の構築【完了】**

1.  **タスク1.1: 完了**
    *   index.htmlファイルを作成
    *   Three.js CDNを追加 (r128)
    *   GLTFLoaderを追加
    *   canvasとscript.jsの読み込みを設定
2.  **タスク1.2: 完了**
    *   style.cssファイルを作成
    *   canvasを全画面表示に設定
    *   ページ全体のスタイルリセットを実装
3.  **タスク1.3: 完了**
    *   script.jsファイルを作成
    *   Three.jsの基本セットアップを実装
    *   レンダリングループを実装
4.  **タスク1.4: 完了**
    *   現時点ではコード規模が小さいため、分割不要と判断
5.  **タスク1.5: 完了**
    *   Gitリポジトリを初期化
    *   .gitignoreファイルを作成
    *   初期ファイルをコミット

**フェーズ2: 基本的な3D空間の作成と表示【完了】**

1.  **タスク2.1: 完了**
    *   PlaneGeometryで3つのレーンを作成（幅2、長さ20）
    *   各レーンに異なる色を適用（緑、青、赤）
    *   レーンを横に並べて配置
2.  **タスク2.2: 完了**
    *   PerspectiveCameraを実装
    *   カメラ位置を設定（高さ3、距離4）
    *   カメラ角度を30度に設定
3.  **タスク2.3: 完了**
    *   AmbientLightを追加（強度0.5）
    *   DirectionalLightを追加（強度0.8）
    *   ライトを右上から当てるように配置
4.  **タスク2.4: 完了**
    *   空色の背景を設定
    *   森林緑の地面（50x50）を作成
    *   地面をレーンの直下に配置
5.  **タスク2.5: 完了**
    *   requestAnimationFrameを使用したレンダリングループを実装

**フェーズ3: プレイヤーキャラクターの作成と操作【完了】**

1.  **タスク3.1: 完了**
    *   GLTFLoaderを使用してRogue.glbをロード
    *   モデルのスケールを0.5に設定
    *   キャラクターを適切な位置（高さ0.3）に配置
2.  **タスク3.2: 完了**
    *   矢印キーによる左右移動を実装
    *   スムーズな移動アニメーションを実装（移動速度0.2）
    *   レーン範囲内（0-2）に移動を制限
3.  **タスク3.3: 完了**
    *   navigator.userAgentでデバイス判定
    *   PC: 矢印キーでの移動
    *   スマートフォン: 50px以上のスワイプで移動

**フェーズ4: 障害物の生成と移動**

1.  **タスク4.1:** 障害物のロード
    *   GLTFLoaderを使用して、障害物のGLBファイルをロード。
    *   ロード完了後、モデルをシーンに追加。
    *   モデルのスケール、位置、回転を調整。
2.  **タスク4.2:** 障害物の移動ロジックの実装
    *   障害物を毎フレーム、手前 (カメラに近い方向) に移動させる関数を作成。
    *   移動速度を設定。
    *   障害物が画面外に出たら、削除する。
3.  **タスク4.3:** 障害物の生成ロジックの実装
    *   一定時間ごとに、新しい障害物を生成する関数を作成。
    *   各レーンからランダムに障害物を生成するようにする。
    *   生成間隔をランダムにする。

**フェーズ5: 衝突判定とゲームオーバー処理**

1.  **タスク5.1:** 衝突判定の実装
    *   プレイヤーキャラクターと障害物の位置を比較し、衝突を検知する関数を作成。
    *   Three.jsのBoundingBoxHelperを使用する (オプション、パフォーマンスに注意)。
    *   または、距離計算により簡易的な衝突判定を行う。
2.  **タスク5.2:** ゲームオーバー処理の実装
    *   衝突が検知されたら、ゲームオーバー画面を表示する関数を作成。
    *   レンダリングループを停止する。
    *   ゲームオーバー画面にスコアを表示する。
    *   リトライボタンを追加する (HTML要素)。
    *   リトライボタンがクリックされたら、ゲームをリセットする関数を呼び出す。

**フェーズ6: スコアリングシステム**

1.  **タスク6.1:** スコア変数の作成
    *   スコアを保持するための変数を作成。
    *   スコアを初期化する関数を作成。
2.  **タスク6.2:** スコア加算ロジックの実装
    *   障害物を回避するごとに、スコアを加算する関数を作成。
3.  **タスク6.3:** スコア表示の実装
    *   HTML要素 (例: `<div>`) を使用して、スコアを画面に表示する。
    *   スコアが更新されるたびに、表示を更新する。

**フェーズ7: UI/UXの改善**

1.  **タスク7.1:** タイトル画面の作成
    *   ゲーム開始前に表示するタイトル画面を作成。
    *   ゲームタイトル、操作説明、スタートボタンなどを表示する。
2.  **タスク7.2:** ゲームオーバー画面の改善
    *   ゲームオーバー画面のデザインを改善する。
    *   スコア、リトライボタンを表示する。

**フェーズ8: デバッグと最適化 (変更なし)**

1.  **タスク8.1:** デバッグ
    *   ゲームプレイ中に発生するバグを修正する。
    *   様々なデバイスで動作確認を行う。
2.  **タスク8.2:** パフォーマンス最適化
    *   Three.jsのパフォーマンス最適化に関する情報を参考に、レンダリング負荷を軽減する。
    *   必要に応じて、モデルのポリゴン数を減らすなどの対策を行う。

**フェーズ9: リリース準備 (変更なし)**

1.  **タスク9.1:** ドキュメント作成
    *   ゲームの説明書を作成する。
    *   使用したライブラリ、アセットのライセンス情報を記載する。
2.  **タスク9.2:** ビルド
    *   HTML, CSS, JavaScriptファイルをまとめて、リリース可能な形式にビルドする。
3.  **タスク9.3:** デプロイ
    *   ゲームをWebサーバーにデプロイする。
